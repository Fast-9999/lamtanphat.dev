---
title: "Java Database v·ªõi JPA: T·ª´ C∆° B·∫£n ƒë·∫øn N√¢ng Cao"
description: "H∆∞·ªõng d·∫´n to√†n di·ªán v·ªÅ Java Persistence API (JPA) v√† Hibernate t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao"
date: 2025-03-15
categories: ["java-mastery-2025"]
tags: ["java", "jpa", "hibernate", "database", "orm"]
featured: false
image: "https://interdata.vn/blog/wp-content/uploads/2025/04/Coding-02.jpg"
draft: false
---

# Java Database v·ªõi JPA: T·ª´ C∆° B·∫£n ƒë·∫øn N√¢ng Cao

## üöÄ JPA l√† g√¨ v√† t·∫°i sao quan tr·ªçng trong 2025?

**JPA (Java Persistence API)** l√† m·ªôt specification Java cho Object-Relational Mapping (ORM) gi√∫p l·∫≠p tr√¨nh vi√™n l√†m vi·ªác v·ªõi database m·ªôt c√°ch d·ªÖ d√†ng v√† hi·ªáu qu·∫£. Trong nƒÉm 2025, JPA v·∫´n l√† standard cho Java database programming v·ªõi h∆°n 80% th·ªã ph·∫ßn.

### üéØ T·∫°i sao JPA quan tr·ªçng trong 2025?

- **Industry Standard**: ƒê∆∞·ª£c s·ª≠ d·ª•ng b·ªüi h·∫ßu h·∫øt c√°c c√¥ng ty Java
- **Productivity**: Gi·∫£m 70% code so v·ªõi JDBC thu·∫ßn
- **Maintainability**: Code d·ªÖ ƒë·ªçc, d·ªÖ maintain h∆°n
- **Performance**: Hibernate v√† c√°c implementation kh√°c ƒë∆∞·ª£c optimize t·ªët
- **Enterprise Ready**: H·ªó tr·ª£ transactions, caching, connection pooling
- **Cloud Native**: T∆∞∆°ng th√≠ch v·ªõi microservices v√† cloud databases

### üìö Roadmap h·ªçc JPA cho ng∆∞·ªùi m·ªõi

```mermaid
graph TD
    A[Java Fundamentals] --> B[SQL & Database Basics]
    B --> C[JDBC Basics]
    C --> D[JPA Fundamentals]
    D --> E[Entity Mapping]
    E --> F[Relationships]
    F --> G[Query Language]
    G --> H[Advanced Features]
    H --> I[Performance Tuning]
```

**L∆∞u √Ω**: B√†i vi·∫øt n√†y t·∫≠p trung v√†o **Intermediate to Advanced Level** (c·∫•p ƒë·ªô 4-9). B·∫°n c·∫ßn c√≥ ki·∫øn th·ª©c c∆° b·∫£n v·ªÅ Java v√† SQL.

## üéØ M·ª•c ti√™u b√†i vi·∫øt

Sau khi ƒë·ªçc xong b√†i vi·∫øt n√†y, b·∫°n s·∫Ω hi·ªÉu:
- **JPA Fundamentals**: Entity, EntityManager, Persistence Context
- **Entity Mapping**: Annotations, relationships, inheritance
- **Query Language**: JPQL, Criteria API, Native SQL
- **Advanced Features**: Caching, batch processing, lazy loading
- **Performance Optimization**: Best practices v√† tuning
- **Real-world Examples**: Practical applications

### üë• Ai n√™n ƒë·ªçc b√†i vi·∫øt n√†y?

- ‚úÖ **Sinh vi√™n IT**: C√≥ ki·∫øn th·ª©c Java c∆° b·∫£n, mu·ªën h·ªçc database programming
- ‚úÖ **Junior Developers**: ƒê√£ bi·∫øt JDBC, mu·ªën n√¢ng cao v·ªõi JPA
- ‚úÖ **Career Changers**: Chuy·ªÉn ƒë·ªïi sang Java Backend development
- ‚úÖ **Full-stack Developers**: Mu·ªën hi·ªÉu s√¢u v·ªÅ data layer
- ‚úÖ **Experienced Developers**: Mu·ªën c·∫≠p nh·∫≠t ki·∫øn th·ª©c JPA hi·ªán ƒë·∫°i

### üéØ Khi n√†o s·ª≠ d·ª•ng JPA?

**JPA** r·∫•t ph√π h·ª£p khi b·∫°n c·∫ßn:
- **Complex Object Mapping**: Objects v·ªõi nhi·ªÅu relationships
- **Rapid Development**: Prototype nhanh v·ªõi database
- **Enterprise Applications**: Large-scale applications v·ªõi complex data
- **Team Development**: Standardized approach cho team
- **Maintainable Code**: Code d·ªÖ ƒë·ªçc v√† maintain

**V√≠ d·ª• th·ª±c t·∫ø**: E-commerce systems, banking applications, CRM systems, content management

## üìö Ki·∫øn th·ª©c n·ªÅn t·∫£ng v·ªÅ Database

### üéØ Database l√† g√¨?

**Database** l√† m·ªôt collection c√≥ t·ªï ch·ª©c c·ªßa data ƒë∆∞·ª£c l∆∞u tr·ªØ v√† truy c·∫≠p electronically. Database gi√∫p l∆∞u tr·ªØ, qu·∫£n l√Ω v√† truy xu·∫•t th√¥ng tin m·ªôt c√°ch hi·ªáu qu·∫£.

**T·∫°i sao c·∫ßn Database?**
- **Data Persistence**: L∆∞u tr·ªØ data l√¢u d√†i
- **Data Integrity**: ƒê·∫£m b·∫£o t√≠nh to√†n v·∫πn c·ªßa data
- **Data Security**: B·∫£o m·∫≠t th√¥ng tin
- **Data Sharing**: Chia s·∫ª data gi·ªØa applications
- **Data Consistency**: ƒê·∫£m b·∫£o t√≠nh nh·∫•t qu√°n

### üéØ SQL l√† g√¨?

**SQL (Structured Query Language)** l√† ng√¥n ng·ªØ standard cho managing relational databases. SQL ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ:
- **CREATE**: T·∫°o tables, databases
- **INSERT**: Th√™m data v√†o tables
- **SELECT**: Truy v·∫•n data t·ª´ tables
- **UPDATE**: C·∫≠p nh·∫≠t data
- **DELETE**: X√≥a data

### Basic SQL Examples

```sql
-- T·∫°o table
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Th√™m data
INSERT INTO users (username, email, password_hash, first_name, last_name) 
VALUES ('john_doe', 'john@example.com', 'hashed_password', 'John', 'Doe');

-- Truy v·∫•n data
SELECT * FROM users WHERE email = 'john@example.com';

-- C·∫≠p nh·∫≠t data
UPDATE users SET first_name = 'Johnny' WHERE id = 1;

-- X√≥a data
DELETE FROM users WHERE id = 1;
```

### üéØ JDBC vs JPA

**JDBC (Java Database Connectivity)** l√† Java API ƒë·ªÉ connect v√† execute queries v·ªõi database. **JPA** l√† higher-level abstraction built tr√™n JDBC.

**So s√°nh JDBC vs JPA:**

| Aspect | JDBC | JPA |
|--------|------|-----|
| **Code Complexity** | Verbose, nhi·ªÅu boilerplate | Concise, √≠t code h∆°n |
| **Object Mapping** | Manual mapping | Automatic mapping |
| **SQL Queries** | Native SQL required | JPQL, Criteria API |
| **Relationships** | Manual handling | Automatic handling |
| **Caching** | No built-in caching | Built-in caching |
| **Learning Curve** | Steeper | Gentler |

**JDBC Example:**
```java
// JDBC - Manual approach
public class UserDaoJDBC {
    public User findById(Long id) {
        String sql = "SELECT * FROM users WHERE id = ?";
        try (Connection conn = DriverManager.getConnection(url, username, password);
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setLong(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setUsername(rs.getString("username"));
                user.setEmail(rs.getString("email"));
                // ... manual mapping
                return user;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

**JPA Example:**
```java
// JPA - Automatic approach
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username")
    private String username;
    
    @Column(name = "email")
    private String email;
    
    // Getters and setters
}

@Repository
public class UserRepository {
    @PersistenceContext
    private EntityManager entityManager;
    
    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }
}
```

## üèóÔ∏è Project Setup

### Maven Dependencies

```xml
<!-- pom.xml -->
<dependencies>
    <!-- JPA API -->
    <dependency>
        <groupId>jakarta.persistence</groupId>
        <artifactId>jakarta.persistence-api</artifactId>
        <version>3.1.0</version>
    </dependency>
    
    <!-- Hibernate Implementation -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>6.4.0.Final</version>
    </dependency>
    
    <!-- H2 Database (for testing) -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>2.2.224</version>
        <scope>runtime</scope>
    </dependency>
    
    <!-- MySQL Driver -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>
    </dependency>
    
    <!-- Connection Pool -->
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>5.0.1</version>
    </dependency>
</dependencies>
```

### Persistence Configuration

```xml
<!-- src/main/resources/META-INF/persistence.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_1.xsd"
             version="3.1">

    <persistence-unit name="jpa-tutorial" transaction-type="RESOURCE_LOCAL">
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        
        <!-- Entity Classes -->
        <class>com.devnetinsights.entity.User</class>
        <class>com.devnetinsights.entity.Product</class>
        <class>com.devnetinsights.entity.Order</class>
        
        <!-- Database Properties -->
        <properties>
            <!-- Database Connection -->
            <property name="jakarta.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="jakarta.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/jpa_tutorial"/>
            <property name="jakarta.persistence.jdbc.user" value="root"/>
            <property name="jakarta.persistence.jdbc.password" value="password"/>
            
            <!-- Hibernate Properties -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/>
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            
            <!-- Connection Pool -->
            <property name="hibernate.connection.provider_class" value="com.zaxxer.hikari.hibernate.HikariConnectionProvider"/>
            <property name="hibernate.hikari.maximumPoolSize" value="10"/>
            <property name="hibernate.hikari.minimumIdle" value="5"/>
        </properties>
    </persistence-unit>
</persistence>
```

## üèõÔ∏è JPA Fundamentals

### üéØ Entity l√† g√¨?

**Entity** l√† m·ªôt Java class ƒë∆∞·ª£c ƒë√°nh d·∫•u v·ªõi `@Entity` annotation, ƒë·∫°i di·ªán cho m·ªôt table trong database. M·ªói instance c·ªßa Entity t∆∞∆°ng ·ª©ng v·ªõi m·ªôt row trong table.

**Key Concepts:**
- **Entity Class**: Java class v·ªõi `@Entity` annotation
- **Entity Instance**: Object c·ªßa entity class
- **Entity Identity**: Primary key c·ªßa entity
- **Entity State**: Transient, Persistent, Detached, Removed

### üéØ Step-by-Step Tutorial: T·∫°o Entity ƒë·∫ßu ti√™n

**B∆∞·ªõc 1: T·∫°o Simple Entity**
```java
// src/main/java/com/devnetinsights/entity/Student.java
package com.devnetinsights.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "students")
public class Student {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name")
    private String name;
    
    @Column(name = "email")
    private String email;
    
    // Constructors
    public Student() {}
    
    public Student(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "', email='" + email + "'}";
    }
}
```

**B∆∞·ªõc 2: T·∫°o Repository**
```java
// src/main/java/com/devnetinsights/repository/StudentRepository.java
package com.devnetinsights.repository;

import com.devnetinsights.entity.Student;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class StudentRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public Student save(Student student) {
        entityManager.persist(student);
        return student;
    }
    
    public Student findById(Long id) {
        return entityManager.find(Student.class, id);
    }
    
    public List<Student> findAll() {
        return entityManager.createQuery("SELECT s FROM Student s", Student.class)
                          .getResultList();
    }
    
    public void deleteById(Long id) {
        Student student = entityManager.find(Student.class, id);
        if (student != null) {
            entityManager.remove(student);
        }
    }
}
```

**B∆∞·ªõc 3: T·∫°o Service**
```java
// src/main/java/com/devnetinsights/service/StudentService.java
package com.devnetinsights.service;

import com.devnetinsights.entity.Student;
import com.devnetinsights.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class StudentService {
    
    @Autowired
    private StudentRepository studentRepository;
    
    public Student createStudent(String name, String email) {
        Student student = new Student(name, email);
        return studentRepository.save(student);
    }
    
    public Student getStudentById(Long id) {
        return studentRepository.findById(id);
    }
    
    public List<Student> getAllStudents() {
        return studentRepository.findAll();
    }
    
    public void deleteStudent(Long id) {
        studentRepository.deleteById(id);
    }
}
```

**B∆∞·ªõc 4: Test Application**
```java
// src/main/java/com/devnetinsights/JpaTutorialApplication.java
package com.devnetinsights;

import com.devnetinsights.entity.Student;
import com.devnetinsights.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JpaTutorialApplication implements CommandLineRunner {
    
    @Autowired
    private StudentService studentService;
    
    public static void main(String[] args) {
        SpringApplication.run(JpaTutorialApplication.class, args);
    }
    
    @Override
    public void run(String... args) throws Exception {
        // T·∫°o student m·ªõi
        Student student1 = studentService.createStudent("John Doe", "john@example.com");
        System.out.println("Created: " + student1);
        
        Student student2 = studentService.createStudent("Jane Smith", "jane@example.com");
        System.out.println("Created: " + student2);
        
        // L·∫•y t·∫•t c·∫£ students
        System.out.println("All students:");
        studentService.getAllStudents().forEach(System.out::println);
        
        // L·∫•y student theo ID
        Student foundStudent = studentService.getStudentById(student1.getId());
        System.out.println("Found student: " + foundStudent);
    }
}
```

### Basic Entity Example

```java
// src/main/java/com/devnetinsights/entity/User.java
package com.devnetinsights.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, unique = true, length = 50)
    private String username;
    
    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private UserStatus status = UserStatus.ACTIVE;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // One-to-Many relationship v·ªõi Order
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Order> orders = new ArrayList<>();
    
    // Constructors
    public User() {}
    
    public User(String username, String email, String passwordHash) {
        this.username = username;
        this.email = email;
        this.passwordHash = passwordHash;
        this.createdAt = LocalDateTime.now();
    }
    
    // Lifecycle Callbacks
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public UserStatus getStatus() { return status; }
    public void setStatus(UserStatus status) { this.status = status; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public List<Order> getOrders() { return orders; }
    public void setOrders(List<Order> orders) { this.orders = orders; }
    
    // Helper methods
    public void addOrder(Order order) {
        orders.add(order);
        order.setUser(this);
    }
    
    public void removeOrder(Order order) {
        orders.remove(order);
        order.setUser(null);
    }
    
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", status=" + status +
                '}';
    }
}

// Enum for User Status
enum UserStatus {
    ACTIVE, INACTIVE, SUSPENDED, DELETED
}
```

### EntityManager v√† Persistence Context

```java
// src/main/java/com/devnetinsights/util/JpaUtil.java
package com.devnetinsights.util;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;

public class JpaUtil {
    private static final String PERSISTENCE_UNIT_NAME = "jpa-tutorial";
    private static EntityManagerFactory entityManagerFactory;
    
    static {
        try {
            entityManagerFactory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
        } catch (Exception e) {
            throw new RuntimeException("Failed to create EntityManagerFactory", e);
        }
    }
    
    public static EntityManager getEntityManager() {
        return entityManagerFactory.createEntityManager();
    }
    
    public static void close() {
        if (entityManagerFactory != null) {
            entityManagerFactory.close();
        }
    }
}
```

## üîó Entity Relationships

### üéØ Relationships trong JPA

JPA h·ªó tr·ª£ 4 lo·∫°i relationships:
- **@OneToOne**: M·ªôt entity li√™n k·∫øt v·ªõi m·ªôt entity kh√°c
- **@OneToMany**: M·ªôt entity li√™n k·∫øt v·ªõi nhi·ªÅu entities
- **@ManyToOne**: Nhi·ªÅu entities li√™n k·∫øt v·ªõi m·ªôt entity
- **@ManyToMany**: Nhi·ªÅu entities li√™n k·∫øt v·ªõi nhi·ªÅu entities

### One-to-Many Relationship

```java
// src/main/java/com/devnetinsights/entity/Order.java
package com.devnetinsights.entity;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "order_number", unique = true, nullable = false)
    private String orderNumber;
    
    @Column(name = "total_amount", precision = 10, scale = 2)
    private BigDecimal totalAmount;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private OrderStatus status = OrderStatus.PENDING;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    // Many-to-One relationship v·ªõi User
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    // One-to-Many relationship v·ªõi OrderItem
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems = new ArrayList<>();
    
    // Constructors
    public Order() {}
    
    public Order(String orderNumber, User user) {
        this.orderNumber = orderNumber;
        this.user = user;
        this.createdAt = LocalDateTime.now();
    }
    
    // Lifecycle Callbacks
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getOrderNumber() { return orderNumber; }
    public void setOrderNumber(String orderNumber) { this.orderNumber = orderNumber; }
    
    public BigDecimal getTotalAmount() { return totalAmount; }
    public void setTotalAmount(BigDecimal totalAmount) { this.totalAmount = totalAmount; }
    
    public OrderStatus getStatus() { return status; }
    public void setStatus(OrderStatus status) { this.status = status; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }
    
    public List<OrderItem> getOrderItems() { return orderItems; }
    public void setOrderItems(List<OrderItem> orderItems) { this.orderItems = orderItems; }
    
    // Helper methods
    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }
    
    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }
    
    public void calculateTotalAmount() {
        totalAmount = orderItems.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

enum OrderStatus {
    PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
}
```

### Many-to-Many Relationship

```java
// src/main/java/com/devnetinsights/entity/Product.java
package com.devnetinsights.entity;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "products")
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "description", columnDefinition = "TEXT")
    private String description;
    
    @Column(name = "price", precision = 10, scale = 2, nullable = false)
    private BigDecimal price;
    
    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;
    
    @Column(name = "sku", unique = true, nullable = false, length = 50)
    private String sku;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Many-to-Many relationship v·ªõi Category
    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
        name = "product_categories",
        joinColumns = @JoinColumn(name = "product_id"),
        inverseJoinColumns = @JoinColumn(name = "category_id")
    )
    private Set<Category> categories = new HashSet<>();
    
    // One-to-Many relationship v·ªõi OrderItem
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<OrderItem> orderItems = new HashSet<>();
    
    // Constructors
    public Product() {}
    
    public Product(String name, String description, BigDecimal price, Integer stockQuantity, String sku) {
        this.name = name;
        this.description = description;
        this.price = price;
        this.stockQuantity = stockQuantity;
        this.sku = sku;
        this.createdAt = LocalDateTime.now();
    }
    
    // Lifecycle Callbacks
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public BigDecimal getPrice() { return price; }
    public void setPrice(BigDecimal price) { this.price = price; }
    
    public Integer getStockQuantity() { return stockQuantity; }
    public void setStockQuantity(Integer stockQuantity) { this.stockQuantity = stockQuantity; }
    
    public String getSku() { return sku; }
    public void setSku(String sku) { this.sku = sku; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public Set<Category> getCategories() { return categories; }
    public void setCategories(Set<Category> categories) { this.categories = categories; }
    
    public Set<OrderItem> getOrderItems() { return orderItems; }
    public void setOrderItems(Set<OrderItem> orderItems) { this.orderItems = orderItems; }
    
    // Helper methods
    public void addCategory(Category category) {
        categories.add(category);
        category.getProducts().add(this);
    }
    
    public void removeCategory(Category category) {
        categories.remove(category);
        category.getProducts().remove(this);
    }
    
    public boolean isInStock() {
        return stockQuantity > 0;
    }
    
    public void reduceStock(int quantity) {
        if (stockQuantity >= quantity) {
            stockQuantity -= quantity;
        } else {
            throw new IllegalArgumentException("Insufficient stock");
        }
    }
}
```

## üîç Query Language

### üéØ JPQL (Java Persistence Query Language)

JPQL l√† ng√¥n ng·ªØ query h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng c·ªßa JPA, t∆∞∆°ng t·ª± nh∆∞ SQL nh∆∞ng l√†m vi·ªác v·ªõi entities thay v√¨ tables.

### Basic JPQL Queries

```java
// src/main/java/com/devnetinsights/dao/UserDao.java
package com.devnetinsights.dao;

import com.devnetinsights.entity.User;
import com.devnetinsights.entity.UserStatus;
import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;
import java.util.List;
import java.util.Optional;

public class UserDao {
    private EntityManager entityManager;
    
    public UserDao(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
    
    // Find all users
    public List<User> findAll() {
        String jpql = "SELECT u FROM User u";
        TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
        return query.getResultList();
    }
    
    // Find user by username
    public Optional<User> findByUsername(String username) {
        String jpql = "SELECT u FROM User u WHERE u.username = :username";
        TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
        query.setParameter("username", username);
        
        try {
            User user = query.getSingleResult();
            return Optional.of(user);
        } catch (Exception e) {
            return Optional.empty();
        }
    }
    
    // Find active users
    public List<User> findActiveUsers() {
        String jpql = "SELECT u FROM User u WHERE u.status = :status";
        TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
        query.setParameter("status", UserStatus.ACTIVE);
        return query.getResultList();
    }
    
    // Find users with orders
    public List<User> findUsersWithOrders() {
        String jpql = "SELECT DISTINCT u FROM User u JOIN u.orders o";
        TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
        return query.getResultList();
    }
    
    // Count users by status
    public Long countUsersByStatus(UserStatus status) {
        String jpql = "SELECT COUNT(u) FROM User u WHERE u.status = :status";
        TypedQuery<Long> query = entityManager.createQuery(jpql, Long.class);
        query.setParameter("status", status);
        return query.getSingleResult();
    }
    
    // Find users with pagination
    public List<User> findUsersWithPagination(int page, int size) {
        String jpql = "SELECT u FROM User u ORDER BY u.createdAt DESC";
        TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
        query.setFirstResult(page * size);
        query.setMaxResults(size);
        return query.getResultList();
    }
}
```

### Criteria API

```java
// src/main/java/com/devnetinsights/dao/ProductDao.java
package com.devnetinsights.dao;

import com.devnetinsights.entity.Product;
import jakarta.persistence.EntityManager;
import jakarta.persistence.criteria.*;
import java.math.BigDecimal;
import java.util.List;

public class ProductDao {
    private EntityManager entityManager;
    private CriteriaBuilder criteriaBuilder;
    
    public ProductDao(EntityManager entityManager) {
        this.entityManager = entityManager;
        this.criteriaBuilder = entityManager.getCriteriaBuilder();
    }
    
    // Find products by price range
    public List<Product> findByPriceRange(BigDecimal minPrice, BigDecimal maxPrice) {
        CriteriaQuery<Product> query = criteriaBuilder.createQuery(Product.class);
        Root<Product> product = query.from(Product.class);
        
        Predicate pricePredicate = criteriaBuilder.between(
            product.get("price"), minPrice, maxPrice
        );
        
        query.where(pricePredicate);
        query.orderBy(criteriaBuilder.asc(product.get("price")));
        
        return entityManager.createQuery(query).getResultList();
    }
    
    // Find products by name pattern
    public List<Product> findByNamePattern(String pattern) {
        CriteriaQuery<Product> query = criteriaBuilder.createQuery(Product.class);
        Root<Product> product = query.from(Product.class);
        
        Predicate namePredicate = criteriaBuilder.like(
            criteriaBuilder.lower(product.get("name")),
            "%" + pattern.toLowerCase() + "%"
        );
        
        query.where(namePredicate);
        
        return entityManager.createQuery(query).getResultList();
    }
    
    // Find products in stock
    public List<Product> findInStock() {
        CriteriaQuery<Product> query = criteriaBuilder.createQuery(Product.class);
        Root<Product> product = query.from(Product.class);
        
        Predicate stockPredicate = criteriaBuilder.gt(
            product.get("stockQuantity"), 0
        );
        
        query.where(stockPredicate);
        
        return entityManager.createQuery(query).getResultList();
    }
    
    // Complex query with multiple conditions
    public List<Product> findProductsWithComplexCriteria(
            String namePattern, 
            BigDecimal minPrice, 
            BigDecimal maxPrice, 
            Integer minStock) {
        
        CriteriaQuery<Product> query = criteriaBuilder.createQuery(Product.class);
        Root<Product> product = query.from(Product.class);
        
        Predicate namePredicate = criteriaBuilder.like(
            criteriaBuilder.lower(product.get("name")),
            "%" + namePattern.toLowerCase() + "%"
        );
        
        Predicate pricePredicate = criteriaBuilder.between(
            product.get("price"), minPrice, maxPrice
        );
        
        Predicate stockPredicate = criteriaBuilder.ge(
            product.get("stockQuantity"), minStock
        );
        
        Predicate finalPredicate = criteriaBuilder.and(
            namePredicate, pricePredicate, stockPredicate
        );
        
        query.where(finalPredicate);
        query.orderBy(criteriaBuilder.desc(product.get("createdAt")));
        
        return entityManager.createQuery(query).getResultList();
    }
}
```

## üöÄ Advanced Features

### üéØ Caching trong JPA

JPA h·ªó tr·ª£ 2 levels c·ªßa caching:
- **First Level Cache**: EntityManager cache (automatic)
- **Second Level Cache**: Shared cache across EntityManagers

### Second Level Cache Configuration

```java
// Entity v·ªõi Second Level Cache
@Entity
@Table(name = "products")
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {
    // ... entity code
}

// Cache configuration trong persistence.xml
<property name="hibernate.cache.use_second_level_cache" value="true"/>
<property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.jcache.JCacheRegionFactory"/>
<property name="hibernate.javax.cache.provider" value="org.ehcache.jsr107.EhcacheCachingProvider"/>
<property name="hibernate.javax.cache.uri" value="ehcache.xml"/>
```

### Batch Processing

```java
// src/main/java/com/devnetinsights/service/BatchService.java
package com.devnetinsights.service;

import com.devnetinsights.entity.Product;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityTransaction;
import java.util.List;

public class BatchService {
    private EntityManager entityManager;
    private static final int BATCH_SIZE = 50;
    
    public BatchService(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
    
    public void batchInsertProducts(List<Product> products) {
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();
        
        try {
            for (int i = 0; i < products.size(); i++) {
                entityManager.persist(products.get(i));
                
                if (i % BATCH_SIZE == 0 && i > 0) {
                    entityManager.flush();
                    entityManager.clear();
                }
            }
            
            transaction.commit();
        } catch (Exception e) {
            transaction.rollback();
            throw e;
        }
    }
    
    public void batchUpdateProducts(List<Product> products) {
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();
        
        try {
            for (int i = 0; i < products.size(); i++) {
                entityManager.merge(products.get(i));
                
                if (i % BATCH_SIZE == 0 && i > 0) {
                    entityManager.flush();
                    entityManager.clear();
                }
            }
            
            transaction.commit();
        } catch (Exception e) {
            transaction.rollback();
            throw e;
        }
    }
}
```

## üèãÔ∏è B√†i t·∫≠p th·ª±c h√†nh

### B√†i t·∫≠p 1: T·∫°o Simple Entity (C∆° b·∫£n)
T·∫°o Book entity v·ªõi c√°c fields c∆° b·∫£n.

```java
// TODO: Implement Book entity
@Entity
@Table(name = "books")
public class Book {
    // Your code here
    // Fields: id, title, author, isbn, price
    // Annotations: @Id, @GeneratedValue, @Column
    // Methods: constructors, getters, setters, toString
}

// Test your implementation
public class BookTest {
    public static void main(String[] args) {
        // Create Book objects
        Book book1 = new Book("Java Programming", "John Doe", "123456789", 29.99);
        Book book2 = new Book("Spring Framework", "Jane Smith", "987654321", 39.99);
        
        // Test toString method
        System.out.println(book1);
        System.out.println(book2);
    }
}
```

### B√†i t·∫≠p 2: T·∫°o Repository v√† Service (Trung b√¨nh)
T·∫°o BookRepository v√† BookService v·ªõi CRUD operations.

```java
// TODO: Implement BookRepository
@Repository
public class BookRepository {
    @PersistenceContext
    private EntityManager entityManager;
    
    // Your code here
    // Methods: save, findById, findAll, deleteById
    // Bonus: findByAuthor, findByTitleContaining
}

// TODO: Implement BookService
@Service
public class BookService {
    @Autowired
    private BookRepository bookRepository;
    
    // Your code here
    // Methods: createBook, getBookById, getAllBooks, deleteBook
    // Bonus: findBooksByAuthor, searchBooksByTitle
}
```

### B√†i t·∫≠p 3: T·∫°o Category Entity (N√¢ng cao)
T·∫°o Category entity v·ªõi Many-to-Many relationship v·ªõi Product.

```java
// TODO: Implement Category entity
@Entity
@Table(name = "categories")
public class Category {
    // Your code here
    // Fields: id, name, description, createdAt, updatedAt
    // Relationship: @ManyToMany v·ªõi Product
    // Lifecycle: @PrePersist, @PreUpdate
}
```

### B√†i t·∫≠p 2: Implement OrderItem Entity
T·∫°o OrderItem entity l√†m bridge table gi·ªØa Order v√† Product.

```java
// TODO: Implement OrderItem entity
@Entity
@Table(name = "order_items")
public class OrderItem {
    // Your code here
    // Fields: id, quantity, unitPrice, subtotal
    // Relationships: @ManyToOne v·ªõi Order v√† Product
}
```

### B√†i t·∫≠p 3: Create Custom Repository
T·∫°o custom repository v·ªõi complex queries.

```java
// TODO: Implement CustomRepository
public interface CustomUserRepository {
    List<User> findUsersWithOrderCount();
    List<User> findTopSpenders(int limit);
    Map<UserStatus, Long> getUserStatusStatistics();
}
```

### B√†i t·∫≠p 4: Implement Audit Trail
Th√™m audit trail ƒë·ªÉ track changes.

```java
// TODO: Create AuditEntity
@MappedSuperclass
public abstract class AuditEntity {
    // Your code here
    // Fields: createdBy, createdAt, updatedBy, updatedAt
    // Lifecycle callbacks: @PrePersist, @PreUpdate
}
```

## üö® Troubleshooting v√† Common Mistakes

### Common JPA Mistakes cho Beginners

1. **Missing @Entity Annotation**
```java
// ‚ùå Wrong - missing @Entity annotation
public class User {
    @Id
    private Long id;
    private String name;
}

// ‚úÖ Correct - with @Entity annotation
@Entity
public class User {
    @Id
    private Long id;
    private String name;
}
```

2. **Missing No-Argument Constructor**
```java
// ‚ùå Wrong - no default constructor
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    public User(String name) {
        this.name = name;
    }
    // Missing no-argument constructor
}

// ‚úÖ Correct - with no-argument constructor
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    public User() {} // Required by JPA
    
    public User(String name) {
        this.name = name;
    }
}
```

3. **Incorrect Primary Key Configuration**
```java
// ‚ùå Wrong - missing @GeneratedValue
@Entity
public class User {
    @Id
    private Long id; // No generation strategy
    private String name;
}

// ‚úÖ Correct - with @GeneratedValue
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
```

### Common JPA Mistakes cho Intermediate

4. **LazyInitializationException**
```java
// ‚ùå Wrong - accessing lazy collection outside session
public List<Order> getUserOrders(Long userId) {
    User user = entityManager.find(User.class, userId);
    return user.getOrders(); // LazyInitializationException
}

// ‚úÖ Correct - use JOIN FETCH
public List<Order> getUserOrders(Long userId) {
    String jpql = "SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :userId";
    TypedQuery<User> query = entityManager.createQuery(jpql, User.class);
    query.setParameter("userId", userId);
    return query.getSingleResult().getOrders();
}
```

2. **N+1 Query Problem**
```java
// ‚ùå Wrong - N+1 queries
public List<User> getUsersWithOrders() {
    List<User> users = entityManager.createQuery("SELECT u FROM User u", User.class)
                                   .getResultList();
    // This will trigger N additional queries for each user's orders
    return users;
}

// ‚úÖ Correct - use JOIN FETCH
public List<User> getUsersWithOrders() {
    String jpql = "SELECT DISTINCT u FROM User u JOIN FETCH u.orders";
    return entityManager.createQuery(jpql, User.class).getResultList();
}
```

3. **Transaction Management**
```java
// ‚ùå Wrong - no transaction
public void saveUser(User user) {
    entityManager.persist(user); // No transaction
}

// ‚úÖ Correct - with transaction
public void saveUser(User user) {
    EntityTransaction transaction = entityManager.getTransaction();
    transaction.begin();
    try {
        entityManager.persist(user);
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw e;
    }
}
```

## üìö T√†i li·ªáu tham kh·∫£o

- [JPA Specification](https://jakarta.ee/specifications/persistence/)
- [Hibernate Documentation](https://hibernate.org/orm/documentation/)
- [Spring Data JPA](https://spring.io/projects/spring-data-jpa)
- [JPA Best Practices](https://www.baeldung.com/jpa-hibernate-persistence-context)

## üéâ K·∫øt lu·∫≠n

Ch√∫ng ta ƒë√£ t√¨m hi·ªÉu v·ªÅ JPA t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao:

- ‚úÖ **Database Fundamentals**: SQL basics, JDBC vs JPA comparison
- ‚úÖ **JPA Fundamentals**: Entity, EntityManager, Persistence Context
- ‚úÖ **Step-by-Step Tutorial**: T·ª´ simple entity ƒë·∫øn complete application
- ‚úÖ **Entity Mapping**: Annotations, relationships, inheritance
- ‚úÖ **Query Language**: JPQL, Criteria API, Native SQL
- ‚úÖ **Advanced Features**: Caching, batch processing, lazy loading
- ‚úÖ **Performance Optimization**: Best practices v√† tuning
- ‚úÖ **Troubleshooting**: Common mistakes v√† solutions

### üöÄ ·ª®ng d·ª•ng th·ª±c t·∫ø trong 2025

JPA l√† **essential skill** cho:
- **Sinh vi√™n IT**: N·ªÅn t·∫£ng v·ªØng ch·∫Øc cho database programming
- **Junior Developers**: Core skill cho Java Backend development
- **Career Changers**: Chuy·ªÉn ƒë·ªïi sang Java v·ªõi modern database techniques
- **Backend Developers**: Essential cho enterprise applications
- **Full-stack Developers**: Understanding data layer architecture
- **System Architects**: Database design v√† optimization

### üìà Learning Path

**Cho Sinh vi√™n/Junior:**
1. **B·∫Øt ƒë·∫ßu**: L√†m b√†i t·∫≠p 1-2 (Simple Entity, Repository)
2. **Th·ª±c h√†nh**: T·∫°o complete CRUD application
3. **M·ªü r·ªông**: H·ªçc relationships (One-to-Many, Many-to-Many)
4. **N√¢ng cao**: H·ªçc JPQL v√† advanced features

**Cho Experienced Developers:**
1. **Th·ª±c h√†nh**: L√†m b√†i t·∫≠p 3-4 (Advanced features)
2. **Performance**: Tuning v√† optimization
3. **M·ªü r·ªông**: H·ªçc Spring Data JPA
4. **Advanced**: JPA v·ªõi microservices, cloud databases

### üéØ Key Takeaways

- **JPA simplifies database programming** - 70% less code than JDBC
- **Entity mapping is powerful** - Automatic object-relational mapping
- **Relationships are handled automatically** - No manual JOIN queries
- **Performance can be optimized** - Caching, lazy loading, batch processing
- **Best practices matter** - Proper entity design, query optimization

### üìö Next Steps

1. **Th·ª±c h√†nh**: L√†m c√°c b√†i t·∫≠p t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao
2. **M·ªü r·ªông**: H·ªçc Spring Data JPA cho rapid development
3. **Performance**: H·ªçc database optimization v√† tuning
4. **Advanced**: H·ªçc JPA v·ªõi microservices architecture
5. **Cloud**: H·ªçc JPA v·ªõi cloud databases (AWS RDS, Azure SQL)

Trong b√†i vi·∫øt ti·∫øp theo, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ **Spring Boot REST API** ƒë·ªÉ t·∫°o web services v·ªõi JPA. H√£y theo d√µi ƒë·ªÉ kh√¥ng b·ªè l·ª°!

---

*B·∫°n c√≥ c√¢u h·ªèi n√†o v·ªÅ JPA kh√¥ng? H√£y ƒë·ªÉ l·∫°i comment ho·∫∑c li√™n h·ªá v·ªõi m√¨nh!* üöÄ

**Tags**: #java #jpa #hibernate #database #orm #2025 #enterprise-java #beginners
